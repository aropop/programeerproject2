% !TeX spellcheck = nl_BE
\documentclass{article}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\thedate}{2 Juni 2014}
\newcommand{\projectname}{ProgrammeerProject 2}
\title{Codeverslag Programmeerproject 2}
\author{Arno De Witte\\
Vrije Universiteit Brussel}
\date{2 Juni 2014}
\begin{document}


\begin{titlepage}
\begin{center}

\includegraphics[width=0.60\textwidth]{./VUB_logo_compact.jpg}~\\[1cm]


\textsc{\Large Programmeerproject 2}\\[0.5cm]

% Title
\HRule \\[0.4cm]
{ \huge \bfseries Codeverslag}\\[0.4cm]

\HRule \\[1.5cm]

% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
Arno \textsc{De Witte}\\
\end{flushleft}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{flushright} \large
\emph{Titularis:}\\ Prof. Dr. Theo Dâ€™Hondt\\
\emph{Assistenten:}\\ Kevin Van Vaerenbergh\\
Lode Hoste\\
Yves Vandriessche
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large \thedate}

\end{center}
\end{titlepage}

%\maketitle
\newpage
\tableofcontents
\newpage


\section{Inleiding}\label{inleiding}
In dit document kan er een handleiding voor gebruikers en een handleiding voor ontwikkelaars gevonden worden. De handleiding voor gebruikers bevat een overzicht van hoe je het systeem moet gebruiken. De handleiding voor ontwikkelaars bespreekt elk onderdeel van de code uitvoerig.\\
Het systeem draagt de naam Control Your House omdat je ermee heel je huis kan bedienen van achter je computer. Verder is het systeem geschreven in het Engels. Zowel de code, commentaar maar ook de interface. De handleiding in dit document is wel in het Nederlands.\\
De code is meegeleverd in hetzelfde archief als waarin dit document kan worden gevonden en is voornamelijk geschreven in Racket, met onderdelen in slip en R5RS.\\
Het doel van dit project is om een domotica systeem te schrijven. Dit systeem bestaat uit 3 delen. Een majordomo: dit is een computer die heel het systeem beheert, een steward: dit zijn kleine computers (bijvoorbeeld een raspberry pi) die commando's krijgen over een lokaal netwerk en deze dan doorsturen naar de devices. De devices zijn het laatste deel, dit zijn slimme apparaten die via het Zigbee protocol verschillende boodschappen (messages) verstaan. Ze kunnen deze uitvoeren en een antwoord terugsturen.\\

\section{Handleiding voor gebruikers}
\label{sec:users}
In dit deel zal er worden uitgelegd hoe je het systeem gebruikt. Er is een opsomming van de functies\ref{sub:features}, hoe het systeem ge\"{i}nstalleerd moet worden\ref{sub:install} en hoe alle functies gebruikt kunnen worden\ref{sub:usage}.

\subsection{Functies}
\label{sub:features}
\begin{itemize}
\item Een simpele, overzichtelijke web interface die kan worden bekeken op alle toestellen die over een browser beschikken en binnen hetzelfde netwerk zitten.
\item Overzicht van alle stewards, met een actuele status. Deze toont aan wanneer bepaalde stewards offline zijn (niet verbonden met netwerk) of hoeveel devices er geconnecteerd zijn aan een bepaalde steward.
\item Mogelijkheid om nieuwe stewards toe te voegen. Je hoeft enkel het ip adres, de poort en de plaats van de steward mee te geven.
\item Automatisch opsporen van devices door de steward. Deze worden getoond in het device overzicht.
\item Bekijken van de actuele status van een device.
\item Rechtstreeks commando's sturen naar devices via het device overzicht. 
\item Ondersteuning voor 2 type devices: ZBS-110 (plug) en ZBS-121 (multimeter).
\item Ophalen van data in de achtergrond. Deze data is wat de verschillende devices als metingen teruggeven.
\item Overzicht waar je de opgehaalde data kan bekijken. Dit kan per kamer of over heel het systeem. Er kunnen waarden worden weggefilterd en er kan voor bepaalde tijdsperioden worden gekozen.
\item Zelf toevoegen van acties. Dit zijn regels die zelf kunnen worden samengesteld. Voor meer uitleg, zie gebruik\ref{sub:usage}.
\item Staat van het systeem wordt persistent opgeslagen. Devices, stewards, acties en data worden veilig opgeslagen. Moest het systeem falen, kan het bij opnieuw opstarten direct hervatten.
\item Stewards en majordomo overleven wanneer de connectie wegvalt. Deze zullen wachten tot er een nieuwe connectie kan worden opgesteld.
\item Mogelijkheid tot simuleren van stewards om te testen.
\end{itemize}
% subsection features (end)

\subsection{Installeren}
\label{sub:install}

Om het systeem te installeren is niet gebruik gemaakt van het racket packaging systeem omdat er verschillende files nodig zijn die niet gemakkelijk te packagen vallen. Ook is de hieronder beschreven methode geldig voor alle besturing systemen.
\begin{enumerate}
	\item Installeer Racket\footnote{http://download.racket-lang.org}. Het systeem is getest onder versie 6.0.
	\item Pak de code uit naar een bepaalde map.
	\item Open DrRacket, open het bestand \emph{start.rkt} en druk rechtsboven op \emph{Doen!}. 
	\item[3b.] Moest het systeem niet snel genoeg lopen, kan in mac en linux via de commandline het commando \lstinline|racket start.rkt| worden uitgevoerd vanaf de map waarin de code zich bevindt. 
	\item Een browser venster opent zich normaal met de interface. Indien dit niet het geval is kan er in een browser naar\\ \emph{http://localhost:8000/servlets/standalone.rkt} worden gesurft.
\end{enumerate}

Om stewards te installeren moet het volgende worden gedaan.
\begin{enumerate}
	\item Kopi\"eer .slip bestanden naar de raspberry pi.
	\item Start via Televisie of scherm: 
	\begin{enumerate}
		\item Verbind je raspberry pi met een televisie of scherm. Zet hem aan.
		\item Connecteer de zigbee module.
		\item Login en ga via het cd (change directory) commando naar de map waarin je de slip bestanden uit het archief hebt gekopi\"eerd.
		\item Om het ip adres te vinden, druk je het commando \emph{ifconfig} onder eth0 (bekabeld) of wlan0 (wireless), het adres achter "inet addr:" is het ip adres van je steward. De standaard poort is 12345.
		\item Voer het commando \emph{./slip} uit.
		\item Nu moet je de code inladen, dit doe je door \emph{(load "run")} te typen en enter te drukken. 
		\item Je mag de pi nu loskoppelen van het scherm.
	\end{enumerate}
	\item Start de pi via een draadloze ssh verbinding:
	\begin{enumerate}
		\item Sluit de pi aan en connecteer de zibee module.
		\item Het opstellen van de ssh connectie doe je door op je computer \emph{ssh pi@IPVANPI} in te geven.
		\item Hierna zijn stappen e tot g van punt 2 dezelfde.
	\end{enumerate}
	\item Voeg de nieuwe steward toe, door in de interface \emph{Stewards} te drukken. Onderaan de tabel kan je een nieuwe steward toevoegen.
\end{enumerate}
% subsection install (end)

\subsection{Gebruik}
\label{sub:usage}
Het gebruik van het systeem is vrij simpel. Wanneer het systeem wordt opgestart, wordt het start scherm weergegeven. Hierop is er een kleine uitleg over het gebruik van het systeem te vinden. In het menu staan, buiten de startpagina,  4 onderdelen. Deze worden elk hieronder uitgebreid besproken. \\

Op de pagina Stewards kan er een tabel met alle stewards die geconnecteerd zijn aan het systeem gevonden worden. Het ID is de manier waarop het systeem een steward identificeert. Het ip is het lokaal adres waarop de steward zich bevindt. Verder kan je de poort ook zien, deze is standaard 12345. De room is de kamer waarin de steward zich bevindt. Deze moet worden meegegeven bij het toevoegen vermits een raspberry pi onmogelijk zelf kan weten waar hij zich bevindt. Er kan ook de status van de steward worden gevonden. Deze staat in de kolom Amount of devices. Normaal toont deze hoeveel devices er verbonden zijn. Maar wanneer er een netwerk probleem is, of de steward is aan het opstarten zal er een status bericht worden weergegeven (bijvoorbeeld "OFFLINE" wanneer de steward onbereikbaar is).\\
Er kan ook een steward worden toegevoegd. Dit wordt gedaan door in de laatste kolom van de tabel de nodige informatie in te geven in de juiste kolom. Het systeem voegt deze steward dan toe en zal zelf mogelijke devices in de kamer zoeken.\\

De pagina Devices toont een tabel met alle slimme toestellen die ondersteunt worden (voorlopig enkel ZBS-110 en ZBS-121). Er kan verschillende informatie over elk toestel worden gelezen. Alsook een status bericht, dit toont in welke staat het toestel zich bevindt. Bij de ZBS-110 (plug) bijvoorbeeld zal er komen wat de werklast is en of het toestel aan staat of niet. \\
Het is ook mogelijk om rechtstreeks naar het toestel een bericht te sturen. Dit kan in de laatste kolom van de tabel. Merk wel op dat dit een tijdje kan duren, het systeem moet namelijk eerst de berichten die in de achtergrond worden verstuurt afronden en erna het gegeven bericht sturen. Het sturen van een bericht duurt gebruikelijk 10 seconden. Nadat het bericht is verstuurt verschijnt het resultaat in dezelfde kolom als waar het bericht is ingegeven. Merk op dat het systeem zelf toestellen detecteert en deze dus niet handmatig kunnen worden toegevoegd. Het instoppen van toestellen is voldoende.\\

\label{subsec:actiondescription}Op de Actions pagina kunnen de acties worden beheert. Een actie bestaat uit een conditie, wanneer deze conditie waar is zal een bepaalde actie worden uitgevoerd. Elke actie heeft een source device, dit is een toestel waaruit de informatie voor de conditie wordt gelezen. De conditie bestaat uit een type, bij temperatuur is dit bijvoorbeeld "TEM"\footnote{Alle types kunnen worden teruggevonden bij de status van toestellen}. Er moet ook een waarde worden meegegeven (bijvoorbeeld 20, van $20\,^{\circ}\mathrm{C}$) en een gelijkheid (bijvoorbeeld kleiner dan).\\
Om de actie iets te laten uitvoeren met je een doeltoestel kiezen en een commando ingeven. Dit commando zal dan naar het toestel worden gestuurd wanneer de conditie waar is.\\
Een uitgewerkt voorbeeld: De elektrische verwarming (aangesloten op een slimme plug) moet worden aangezet wanneer de temperatuur onder de 15 graden zakt. Het type is TEM van temperatuur. De waarde is 15, het doeltoestel is de plug waarin de elektrische verwarming zit, het brontoestel (source device) is de multimeter die te temperatuur in de kamer meet en gelijkheid is kleiner dan ($<$).\\
Acties kunnen worden bekeken, verwijderd en toegevoegd op deze pagina.\\

De laatste pagina is de data pagina. De data die wordt verzameld zijn de status berichten van de verschillende devices, deze worden verzameld in de achtergrond door de majordomo. Op deze pagina staat een korte intro over de data, een lijst met alle kamers waarin er data is verzameld, een link naar de grafiek met alle verzamelde data en een paar feiten over het systeem. Wanneer er wordt verder gegaan naar de data over bijvoorbeeld de badkamer, wordt er een grafiek weergegeven voor de data die in die kamer is verzameld. Er kunnen verschillende data types worden weggelaten en andere tijdsperiodes gekozen. Wanneer er bijvoorbeeld voor minuten wordt gekozen wordt de data van de laatste minuten getoond. Hetzelfde voor dagen enzovoort.\\
% subsection usage (end)


\subsection{Screenshots}
\label{sub:screenshots}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{Screenshot1.png}
\caption{Startscherm}
\label{screen1}
\end{figure}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{Screenshot2.png}
\caption{Steward scherm}
\label{screen2}
\end{figure}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{Screenshot3.png}
\caption{Toestel pagina}
\label{screen3}
\end{figure}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{Screenshot4.png}
\caption{Actie pagina}
\label{screen4}
\end{figure}
\begin{figure}[htp]
\centering
\includegraphics[scale=0.30]{Screenshot5.png}
\caption{Data grafiek}
\label{screen5}
\end{figure}
% subsection screenshots (end)

% section users (end)
\newpage

\section{Ontwikkelaars handleiding}
\label{sec:developers}
\subsection{Algemeen}
\label{sub:intro}
Hieronder volgt een beschrijving van het systeem voor ontwikkelaars. \\
Zoals eerder vermeld bestaat het systeem uit 3 verschillende pionnen. De majordomo (master genoemd), de stewards en de devices. De master is geschreven in racket en maakt gebruik van het klasse systeem dat bestaat in racket. Terwijl de steward geschreven is in slip een variatie van R5RS.\\
Er zijn enkele naming conventions in dit systeem. Eigenschappen van da objecten worden met een tilde geschreven. Bijvoorbeeld de master\ref{ssub:master} heeft als eigenschap een lijst met stewards. Deze wordt dan geschreven als $stewards\sim$.\\
Klassen worden genoteerd met een percent teken achter, bijvoorbeeld \emph{master\%}.\\
Omdat racket geen statische procedures ondersteunt (en alle publieke functies dus enkel kunnen worden opgeroepen met een instantie van een klasse), worden er waar nodig statische objecten aangemaakt. Dit zijn instanties van de klasse waar de data velden irrelevant zijn. Deze worden geschreven met een dollar teken achter. Bijvoorbeeld de statische variant van action wordt dan $action\$$.\\
% subsection intro (end)

\subsection{Klasse overzicht majordomo}
\label{sub:class}
Hieronder staat uitleg bij alle klassen die op de master draaien.
\subsubsection{Master}
\label{ssub:master}
Het kloppende hart van het systeem. Wanneer de klasse wordt aangemaakt moet de \textbf{init} procedure worden opgeroepen. Deze initialiseert de master, maakt een content-storer\ref{ssub:content-storer} en content-provider\ref{ssub:content-provider} klassen aan. Aan de content-provider gaat dan een lijst met stewards worden opgevraagd, deze worden op hun beurt dan ge\"initialiseerd. Verder vraagt het ook nog een lijst met acties op. Er worden ook 2 threads gestart. De eerste, save-thread, gaat na een bepaald interval de staat (stewards en devices) opslaan, dit gebeurt door de \textbf{save} procedure op te roepen. De andere gaat data verzamelen (statussen opvragen) en erna checken of er geen actions\ref{ssub:action} kunnen worden uitgevoerd. De procedures \textbf{collect-data} en \textbf{check-actions} zijn hier respectievelijk verantwoordelijk voor.\\
Verder heeft de master nog volgende procedures, deze worden veelal door de front-end\ref{ssub:front-end} aangesproken.
\begin{itemize}
	\item[get-all-rooms] geeft een lijst met alle kamers die in het systeem zitten terug. Deze worden opgeslagen in de database. Meer kamers kunnen worden in de settings bestand worden toegevoegd.
	\item[get-stewards] is een getter voor de stewards.
	\item[add-steward] voegt een nieuwe steward toe, gegeven een ip adres (in de vorm van een string) en een poort. Deze wordt dan aan de lijst toegevoegd. Er wordt ook save opgeroepen omdat we een aangepaste staat hebben.
	\item[get-steward] geeft het steward object terug voor een bepaald steward-id.
	\item[get-steward-for-device] geeft de steward terug die het device heeft dat bij een bepaald device-id hoort.
	\item[get-actions] geeft de lijst met actions terug.
	\item[add-action] voegt een actie object toe aan de lijst. Dit object wordt direct opgeslagen door de content-storer.
	\item[delete-action] gaat een action verwijderen. Er moet een id worden meegegeven. Deze wordt dan door de content-storer ook verwijderd uit de database.
	\item[check-actions] gaat alle acties na. Er wordt telkens de execute procedure opgeroepen met het passend steward object. Zo wordt nagegaan of de actie al dan niet moet worden uitgevoerd.
	\item[destruct] een destructor, deze gaat de threads be\"eindigen nadat een laatste keer de staat is gesaved.
	\item[get-facts] is een dispatch functies die verdeelt tussen verschillende feiten. Zoals bijvoorbeeld hoeveel data objecten er al zijn verzameld.
	\item[get-data] dient als tussen stuk tussen de front-end en de database met data objecten. 
\end{itemize}
% subsubsection master (end)

\subsubsection{Front end}
\label{ssub:front-end}
In dit data object wordt de interface geladen. Omdat we met een webinterface werken, wordt al de opmaak en styling gedaan in HTML en CSS. Er wordt gebruik gemaakt van het dynamische template systeem dat in racket zit\footnote{http://docs.racket-lang.org/web-server/templates.html}. Dit gaat html bestanden inlezen en wanneer het een @ tegenkomt wordt alles wat erachter komt ge\"evalueerd. Wanneer er bijvoorbeeld @variabele staat, zal dit vervangen worden door de waarde van de variabele. Er kunnen ook expressies worden meegegeven en ge\"itereerd worden over lijsten. De HTML template bestanden staan in de template map van het project. Het stijl bestand staat in de root van het project. De gebruikte iconen en afbeeldingen zijn te vinden in de images map.\\
Om grafieken\footnote{http://www.flotcharts.org/} en een interactieve weergaven van berichten in  de interface te bekomen wordt er ook gebruik gemaakt van javascript en jQuery\footnote{http://jquery.com/}. Alle javascript libraries gebruikt in het project zijn te vinden in de js map. De gebruikte scripts (die zelf geschreven zijn) staan in de template bestanden waar ze worden toegepast.\\
Om aan te tonen dat de front-end kan worden uitgewisseld met bijvoorbeeld een front-end geschreven in racket GUI, is er een abstracte klasse front-end met een start procedure. Deze wordt in dit project dan ge\"implementeerd door html-front-end.\\
De belangrijkste procedure van deze klasse is \textbf{dispatch}. Deze neemt http requests en geeft responses terug. Dit gebeurt naargelang de aard van deze request. Bijvoorbeeld bij het opvragen van een pagina is er een GET request page met als waarde welke pagina er moet worden voorzien. \\
Bij kleinere calls, zoals voor de status, die via ajax worden gestuurd wordt rauwe data terug gestuurd. Maar bij pagina requests wordt heel de html pagina teruggegeven.\\ 
% subsubsection front-end (end)

\subsubsection{Database saveable}
\label{ssub:db-saveable}
Is een abstrace klasse die bepaalt welke procedures klassen moeten hebben om te kunnen worden opgeslagen in de database. Hieronder een kleine uitleg bij elk van deze procedures:
\begin{itemize}
		\item[store-sql] geeft de sql query terug die het object opslaagt. Dit in de vorm van een string. Omdat bij een insert het object zijn id moet weten of hij bij het opslaan ook andere objecten moet opslaan, kan er ook een conscel worden teruggegeven. In de car zit dan de sql en in de cdr een lambda procedure, deze neemt 2 argumenten: het id waarmee het ge\"insered is en de content-storer zodat het ook andere objecten kan opslaan.
		\item[get-sql] de select sql die nodig is om een object van dit type uit de database op te halen. Er moet wel nog een id worden achter geplakt. Dit is een statische procedure.
		\item[create-lambda] is de lambda die evenveel argumenten neemt als er velden wordt geselecteerd door de get-sql. Als resultaat geeft het een nieuw object van dit type terug. Natuurlijk is dit ook een statische procedure.
		\item[delete-sql] geeft de sql om de instatie van het object ter verwijderen uit de database.
\end{itemize}
% subsubsection db-saveable (end)

\subsubsection{Steward wrapper}
\label{ssub:steward}
Deze klasse is een abstractie van de echte steward. Dit wil zeggen dat het een racket object is. Maar dat de procedures geen effectieve berekeningen doen. De oproepen worden doorgestuurd naar de echte steward over het TCP/IP protocol. De steward op de majordomo is hierbij de client, terwijl de echte steward fungeert als server. Dit wil zeggen dat de steward wrapper een connectie aanvraagt aan de echte steward.\\
De klassen implementeert de database-saveable klasse. Zo kunnen de stewards (die deel uitmaken van de staat van het systeem) persistent worden gemaakt. \\
De klasse heeft als eigenschappen: een lijst van device objecten, een ip en poort waarover de connectie verloopt, een plaats, een verwijzing naar het master object, input- en outputport die gebruikt wordt om berichten te sturen naar de effectieve steward, een status die zegt of de echte steward wel online is, een communication lock die ervoor zorgt dat de thread niet interfereert met andere communicatie en een variabele die zegt of er al eens is gezocht voor devices.\\
Bij het aanmaken van een instantie wordt er een thread ge\"initialiseerd, deze gaat in de achtergrond de devices en de status van elk device vragen. Deze wordt dan opgeslagen in respectievelijk dit object en het device object. Zo worden deze gegevens gecached.\\
Hieronder nog een bespreking van de overige noemsenwaardige procedures:
\begin{itemize}
  	\item[connect-to-pi] stelt de verbinding op over TCP/IP. Vult de waardes van de input en output porten maar ook van de status. 
  	\item[send-mes-to-pi] is de private procedure die de messages over de output-port schrijft.
  	\item[get-device] geeft het juiste device object terug voor een gegeven device-id.
  	\item[online?] predicaat dat zegt of de steward online (en dus operationeel) is.
  	\item[get-device-count] zegt hoeveel devices er geconecteerd zijn aan deze steward.
  	\item[get-devices] geeft een lijst met device objecten terug. Deze lijst is gecached aan de hand van de thread.
  	\item[get-devices-force-discovery] gaat de devices effectief ophalen. Dit is de niet gecached versie.
  	\item[send-message-to-device] verstuurt een bericht naar een device. Deze effectief naar de fysieke devices gestuurt en dus niet lokaal naar het object.
  	\item[get-device-type] geeft het type van een device voor een bepaald device-id.
  	\item[get-device-status] geeft de gecached versie van de status terug. Deze wordt geparsed naar typed-data objecten. De status van een device is het  resultaat van een "GET" message.
  	\item[get-device-status-force-message] stuurt effectief de GET message om de status te bemachtigen.
  	\item[message-all-devices] stuurt een bericht naar alle devices.
  	\item[has-device?] predicaat dat zegt of een device verbonden is met deze steward.
\end{itemize}
% subsubsection steward (end)

\subsubsection{Device wrapper}
\label{ssub:device-wrapper}
Net zoals de bij de steward, is er een abstractie van de devices die op de majordomo zelf draait. Deze wrapper heeft minder procedures en wordt meer gebruikt om data over het device op te slaan. Het heeft alle eigenschappen die een echt device ook heeft: een communicatie adres waar berichten naar worden verzonden, een plek in het huis waar het zich bevindt, een type (bijvoorbeeld ZBS-110). Als extra eigenschappen heeft het ook een status, deze wordt gezet door de thread in de steward, een boolean die zegt of het device effectief gevonden is en een boolean die zegt of het device al is opgeslagen in de database.\\
Als procedures heeft het een serialize en deserialize procedure om het communicatie adres op te slaan. Er is echter een bug tussen racket en slip waardoor vectoren niet correct worden uitgelezen na een write over een output port. Hierdoor is het communicatie adres lokaal altijd null. Verder is er nog een procedure die het communicatie adres omzet in een leesbare string. Deze heeft met de bug ook niet veel nut.\\
Net zoals de steward wrapper, is de device wrapper ook een implementatie van database-saveable en kunnen devices (die een deel uitmaken van de staat van het systeem) ook worden opgeslagen in de database.
% subsubsection device-wrapper (end)

\subsubsection{Database manager}
\label{ssub:database-manager}
Deze klasse is verantwoordelijk voor het beheer van de database. Wanneer de database nog niet is ge\"initialiseerd gaat deze klasse hiervoor zorgen. Het handelt ook alle intereactie met de database af. Als database software is gebruik gemaakt van sqlite3\footnote{http://sqlite.org}. Racket voorziet hiervoor een interface binnen de taal\footnote{http://docs.racket-lang.org/db/}.\\
Het database bestand (sqlite slaat de database op in 1 bestand) is standaard \emph{./database/default} maar kan worden aangepast in het settingsbestand. De eigenschap install-query bevat een lijst met alle queries die worden gebruikt om de database aan te maken. Dit zijn voornamelijk create tables. Maar er wordt ook een lijst van kamers ingevoegd. Ook deze kan worden aangepast in het settingsbestand\ref{ssub:rest}.\\
Er zijn 5 tabellen die worden gebruikt:
\begin{itemize}
\item[Action] is de tabel waar de acties worden in opgeslagen. Deze onthoud een id, het type, de waarde, het commando, de gelijkheid, het doeldevice en het bron device.
\item[Data] deze tabel slaagt een timestamp, type, waarde en het device waarvan het komt op voor een stuk data.
\item[Steward] slaag het ip, de poort en de room op voor een steward. De steward krijgt ook een id om zich te kunnen identificeren.
\item[Device] houdt het device-id, type, communicatie adres en de steward waarbij het device hoort op.
\item[Room] een simpele tabel met 1 kolom de naam van de kamer.
\end{itemize}
Als voornamelijkste procedures zijn er de execute procedures, deze voeren een sql query uit. Er zijn 2 varianten: \textbf{execute/return} gaat het resultaat van de query parsen in db-table-data\ref{ssub:db-table-data}, bij \textbf{execute/no-reuturn} wordt het resultaat genegeerd. Dit maakt het uitvoeren van queries zonder resultaat performanter.\\
Verder is er nog \textbf{last-inserted-id} die de primary key terug geeft van de laatst uitgevoerde query en 2 hulp procedures die initialiseren als dat nog niet is gebeurt (\textbf{do-init-test} en \textbf{is-table-installed?}.
% subsubsection database-manager (end)

\subsubsection{Database table data}
\label{ssub:db-table-data}
Deze klasse zorgt voor een abstractie van het resultaat dat je krijgt bij het uitvoeren van een sql query. Het heeft als eigenschappen een index die bijhoud welke rij er verwerkt wordt, at-end die bijhoud of we op het einde van de data zitten, het data element zelf, dit is een lijst van vectoren,  de huidige rij (current-rows) en hoeveel rijen er zijn.\\
Een overzicht van de procedures:
\begin{itemize}
	\item[get-next-row] geeft de volgende rij terug als vector.
	\item[get-current-row-colum] geeft de waarde in de huidige rij op een bepaalde kolom terug.
	\item[get-colum] geeft een hele kolom als lijst terug.
	\item[number-of-rows] geeft het aantal rijen terug. Dit aantal wordt slechts 1 maal geteld door length.
	\item[get-next-row-colum] geeft een bepaalde kolom van de volgende rij terug. 
\end{itemize}
% subsubsection db-table-data (end)

\subsubsection{Content storer}
\label{ssub:content-storer}
Deze klasse slaagt objecten (waarvan de klasse de database-saveable abstrace klasse uitbreid) op in de database. Dit gebeurt in de \textbf{store} procedure. Deze maakt gebruik van de store-sql procedure. De klasse is ook verantwoordelijk voor het verwijderen van objecten uit de database. Dit wordt enkel gebruikt door de action klasse. De procedure die dit doet is \textbf{unstore}.
% subsubsection content-storer (end)

\subsubsection{Content provider}
\label{ssub:content-provider}
De content-provider klasse levert objecten die opgeslagen zijn in de database. Omdat niet alle objecten op dezelfde manier kunnen worden opgehaald (stewards moeten hun devices ophalen bijvoorbeeld) is er voor elk soort van object een aparte procedure. De meeste hebben wel dezelfde structuur. Ze sturen een sql query naar de database-manager, de database-table-data die het resultaat van de query wordt dan gebruikt om een nieuw object aan te maken. Dit wordt dan in een lijst met de andere objecten teruggegeven. De volgende lijst geeft een overzicht van alle procedures:
\begin{itemize}
		\item[get-stewards] geeft een lijst met alle opgeslagen stewards. De master moet als argument worden meegegeven omdat deze nodig is bij de aanmaak van een steward object.
		\item[get-devices] geeft als resultaat een lijst van devices die bij een bepaald steward-id horen, de plaats waar deze devices zich bevinden moet ook als argumenten worden meegegeven.
		\item[get-actions] geeft een lijst met de opgeslagen action objecten.
		\item[get-rooms] geeft een lijst met alle opgeslagen kamers terug.
		\item[get-all-data] maakt een lijst met alle opgeslagen data.
		\item[get-data-for-device-type] geeft de data voor een bepaald device type.
		\item[get-data-for-device-ids] geeft alle data verzameld door bepaalde devices.
		\item[handle-data] priv\'e procedure die de query voor data verwerkt.
		\item[get-amount-of-data] berekent het aantal elementen in de data tabel.
		\item[last-data-stored-timestamp] geeft van het laatste opgeslagen data object de timestamp terug. 
\end{itemize}
% subsubsection content-provider (end)

\subsubsection{Action}
\label{ssub:action}
De functionaliteit van een actie wordt beschreven in de gebruikershandleiding\ref{subsec:actiondescription}. Hier zal enkel over de implementatie worden gesproken van deze klasse.\\
Deze klasse implementeert ook de database-saveable klasse, zo kan ze gemakkelijk worden opgeslagen.\\
Er zijn een aantal gelijkheden die worden ondersteund. Er kunnen gemakkelijk nieuwe worden toegevoegd, dit kan door in het action.rkt bestand bij supported-equalities een nieuwe conscel toe te voegen. In de car moet dan een string representatie van de gelijkheid zitten en in de cdr een lambda die 2 elementen vergelijkt.\\
De belangrijkste procedure van deze klasse is \textbf{execute}, deze gaat de actie uitvoeren als de gelijkheid true geeft. Hiervoor worden 2 steward objecten gevraagd. Bij de eerste gaat de status van het brondevice worden opgevraagd. Dan wordt de gelijkheid berekent als deze true geeft, wordt het commando via de tweede steward naar het doeldevice gestuurd.\\
Verder is er nog een \textbf{serialize-eq} en \textbf{deserialize-eq} procedure om de gelijkheid om te zetten naar een string.\\
% subsubsection action (end)

\subsubsection{Generic data}
\label{ssub:generic-data}
Deze klasse stelt allerhande data voor. De data wordt opgesplits in een naam (of type) met een waarde. Naar gelang het gebruik wordt deze 3 keer uitgebreid. Telkens wordt er een waarde toegevoegd, hieronder een overzicht.
\begin{itemize}
	\item[Generic-data] de basis klasse, onthoud enkel een naam en waarde en heeft hiervoor getters en setters\footnote{simpele procedures die een waarde teruggeven of aanpassen.}.
	\item[Response-message] deze klasse heeft als extra eigenschap een device-id waarvan de message afkomstig is. De naam wordt hier gebruikt als type van data bij temperatuur bijvoorbeeld TEM.
	\item[Typed-data] deze data is een response message maar de data wordt ge\"interpreteerd als data van een bepaald type, zoals bijvoorbeeld temperatuur e.a.
	\item[Dated-data] dit is typed-data die uit de database komt. Bij opslaan krijgt de data namelijk een timestamp wat de extra eigenschap is van deze klasse. Er zijn ook enkele procedures om de tijdseenheden gemakkelijk uit te lezen. De timestamp is namelijk een string.
\end{itemize}
% subsubsection generic-data (end)

\subsubsection{Parser}
\label{ssub:parser}
Dit is een statische klasse (dit wil zeggen dat het geen nut heeft om er een instantie van te maken) en heeft dus enkel publieke procedures die niet afhankelijk zijn van een bepaalde staat.\\
De klasse bevat procedures die strings omzet naar generic-data objecten (of een uitgebreidere klasse hiervan) en omgekeerd. Dit is nodig in twee gevallen: wanneer we een message krijgen van een device (\textbf{parse-message}) en wanneer we een json lijst moeten maken voor flot (\textbf{unparse-to-json}).\\
% subsubsection parser (end)

\subsubsection{Overige}
\label{ssub:rest}
Verder worden er nog een paar kleinere bestanden gebruikt. Macros bevat een macro die het defini\"eren van verschillende waarden in racket versimpeld. Settings bevat een lijst met opties, deze kan je als ontwikkelaar zelf aanpassen om het systeem beter naar de eigen wensen te doen werken. Start is een script dat het systeem gaat opstarten. Start-simulation gaat een simulatie van een steward opstarten. Deze draait dan op het ip van de computer waarop die gestart is. Als data dezelfde is dan de majordomo kan gebruik gemaakt worden van ``localhost" of ``127.0.0.1" om ernaar te verwijzen.
% subsubsection rest (end)

% subsection class (end)

\subsection{Klasse overzicht steward}
\label{sub:class-steward}
Naast de majordomo draait ook een klein deel van code op de steward. Deze zet de messages die het krijgt van de master (verstuurd vanuit de steward-wrapper\ref{ssub:steward}) en zet deze om naar het zigbee protocol. Verder is hij verantwoordelijk voor het ontdekken van devices binnen 1 kamer.\\
De klassen op de steward draaien in slip\footnote{https://gitlab.soft.vub.ac.be/yvdriess/rpislip/}. Deze taal lijkt op R5RS en heeft dus ook geen native ondersteuning voor klassen. Om dit toch te verwezenlijken wordt gebruik gemaakt van een geneste procedure, die als resultaat een dispatch procedure teruggeeft. Via deze kunnen dan verscheidene procedures worden opgeroepen aan de hand van berichten (in de vorm van symbols).\\
Merk op dat voor de slip versies van deze klassen ook een R5RS versie is. Deze is gelijkaardig aan de slip versie en wordt gebruikt voor de simulatie van het systeem\ref{sub:simulation}. Er is een kopie gemaakt in R5RS omdat slip nog steeds verscheidene bugs bevat (zoals memory leaks). Ook kan in R5RS racket code worden ge\"importeert, vermits de simulatie in racket is geschreven is dit handig.
\subsubsection{Device}
\label{ssub:device-on-steward}
Dit is een simpele data klasse. Ze heeft dezelfde eigenschappen als de racket versie\ref{ssub:device-wrapper}. De enige procedure is \textbf{serialize} deze zet het device object om in een vector deze kan dan worden verzonden over de connectie naar het racket steward object.
% subsubsection  (end)

\subsubsection{Steward}
\label{ssub:steward-slip}
Deze klasse behandeld de messages die het krijgt van de majordomo. Er is een \textbf{dispatch} procedure die wordt gebruikt om de message die het krijgt te versturen naar de juiste procedure. Wanneer een steward object wordt aangemaakt zal er oneindig worden geloopt. Dit omdat er een connectie wordt opgestart door tcp-accept, waarna er telkens wordt gewacht tot er een bericht wordt gestuurd (read procedure blokkeert). Dit gebeurt in de \textbf{loop} procedure.\\
Er zijn in deze klasse een hele hoop hulp procedures. Bij deze legt de naam de procedure helemaal uit. Sommig van deze procedures zijn procedures die in slip nog niet zijn ge\"implementeerd of in een bepaald stadium van de taal een bug bevatte. Om compatibel te blijven met oudere versies compatibel te blijven zijn deze nog aanwezig in de code. Een kleine opsomming:
\begin{itemize}
	\item displayln
	\item error
	\item bytevector-$>$hexvector 
	\item bytevector-$>$string
	\item list-$>$bytevector (voegt op het einde een linefeed (0x0A) toe)
	\item bytevector-equal?
	\item string-$>$list
	\item substring
	\item string-$>$bytevector
\end{itemize}
Bij het opstarten wordt via xbee-discover en xbee-list een lijst met devices gedetecteerd, deze moeten worden omgezet naar device objecten. Dit wordt gedaan door \textbf{create-device} over de lijst met die wordt teruggegeven uit xbee-list te mappen. Dit wordt gedaan in \textbf{build-device-list} die in elke loop wordt opgeroepen. Zo wordt voor elk bericht wordt afgehandeld de lijst met devices ge\"updatet.\\
Het sturen van berichten naar een device gebeurt in \textbf{send-message-to-device}, deze gaat eerst kijken wat voor soort antwoord we verwachten van het device. Vermits er meerdere berichten van het device binnen komen, moet het bericht dat wij willen ontvangen gefilterd worden.  Daarna wordt het bericht omgezet naar een bytevector en verzonden. Het resulterende frame wordt dan terug omgezet naar een string en teruggegeven als resultaat van de procedure.\\
\textbf{Send-bytes-to-device} behandelt het eigenlijke versturen van bytevectoren. De bytevector wordt weggeschreven via xbee-write, waarna er over de binnenkomende frames wordt geloopt. Pas wanneer alle frames zijn uitgelezen en er een ``goed'' antwoord binnen is stop deze lus. Het antwoord moet voldoen aan een verwachting. Dit voorkomt dat wanneer we een bericht sturen om een lamp aan te zetten, we een status bericht inlezen. Meer informatie over het protocol \ref{sub:protocol}.\\
Om de devices tijd te geven om te antwoorden zijn er de procedures \textbf{sleep} en \textbf{sleep2} sleep gaat een bepaald aantal miliseconden wachten, sleep2 gaat wachten tot wanneer xbee-ready zegt dat er een frame kan worden uitgelezen.\\
Er zijn op dit moment twee types van devices ondersteunt. Om meer types toe te voegen moet er in de lijst \textbf{SUPPORTED-DEVICES} een nieuwe vector worden toegevoegd. Op de eerste plaats moet een symbool met de naam van het soort device, op de tweede plaats moet de string van het exacte type device staan. Deze zijn standaard 6 characters lang. Op de derde plaats komt een beschrijvend type (bijvoorbeeld thermometer). De laatste plaats in de vector moet een lijst van conscellen komen. In elke conscel staat een bericht dat kan verstuurt worden en een verwacht antwoord. Dit kan het begin van een string zijn (bijvoorbeeld "ack") of de volledige string. Wanneer er geen specifiek antwoord nodig is kan er een symbool worden geplaatst.\\
% subsubsection steward-slip (end)

% subsection class-steward (end)


\subsection{Protocol}
\label{sub:protocol}
Er worden 2 protocols gebruikt in dit systeem. E\'en om te communiceren tussen de majordomo en de steward en \'e\'en om te communiceren tussen de steward en de devices. Voor het eerste wordt gebruik gemaakt van het TCP/IP protocol. Voor het tweede wordt Zigbee gebruikt.
\subsubsection{TCP/IP protocol}
\label{ssub:tcp-ip}
Vermits racket en slip een goed ondersteuning hebben voor tcp/ip is dit een simpel protocol. Wanneer er een connectie wordt aangemaakt worden er op server en client een input en output-port aangemaakt. Over deze poort kunnen alle (basis) datastructuren worden geschreven. Deze kunnen dan gemakkelijk worden uitgelezen aan de andere kant. Enkel de objecten moeten dus worden geserializeerd.\\
De steward speelt hier de rol van server, hij kan enkel berichten ontvangen en de antwoorden terugschrijven. Er moet enkel een poort worden meegegeven aan tcp-accept, op deze poort zal geluisterd worden tot er een client zich aanmeld. De client is hier de majordomo, deze heeft het ip en de poort nodig waarop de steward luistert.\\
Omdat we zo een goed ondersteuning hebben, is het oproepen van procedures vanaf de majordomo naar de steward eigenlijk heel erg simpel: er wordt een symbool gestuurd met mogelijk nog enkele argumenten, de steward dispatched dit symbool en schrijft het antwoord van de procedure terug. Alle mogelijke berichten zijn dus terug te vinden in de dispatch procedure van de steward. Hier kunnen er ook extra worden toegevoegd.
% subsubsection tcp-ip (end)

\subsubsection{Zigbee}
\label{ssub:zigbee}
Het zigbee protocol is ingewikkelder dan het TCP/IP protocol omdat er op een lager niveau moet gewerkt worden. Heel het protocol zit verwerkt in de steward en is geschreven in slip. Elk device heeft een device-id en een communicatie adres. Dit adres is een 64 bit bytevector. Om devices te vinden moet er \textbf{xbee-discover} worden opgeroepen, waarna een \textbf{xbee-tick} moet volgen. Deze gaat een broadcast bericht sturen naar alles devices. Na een bepaalde tijd zullen de antwoorden van deze devices binnenlopen. Omdat er een tijdje tussen de discover en het antwoord zit, worden de devices (id en communicatie adres) opgeslagen in een buffer. Deze kan worden uitgelezen door \textbf{xbee-list}. Dit gebeurt nog voor de communicatie met de majordomo wordt opgestart.\\
Wanneer er een bericht moet worden gestuurd, moet dit bericht van string naar bytevector worden omgezet. Deze bytevector moet eindigen op 0x0A (linefeed). Daarna kan deze worden weggeschreven via \textbf{xbee-write}, dit gevolgd door \textbf{xbee-tick}. Er kunnen nu frames worden ingelezen. Dit gebeurt met de \textbf{xbee-read} procedure. Deze frames zijn bytevectors met variabele lengte. Op de eerst plaats in de vector staat steeds het frame-type. Er worden zijn twee significante frame-types. 0x90 is een data frame. Hierin zit data die een antwoord zou kunnen zijn op de boodschap die je zelf hebt gestuurd. 0x8B zijn recieve status frames. Deze frame zegt of je boodschap succesvol is verzonden. Wanneer dit het geval is wordt er gewacht op dit (0x90) frame. Anders wordt de boodschap opnieuw verzonden door xbee-write. Als er andere typen frames worden ingelezen worden deze genegeerd.\\
Merk op dat het versturen en ontvangen van berichten naar devices lang kan duren. Dit komt door 2 redenen, het duurt lang voor een device een antwoord heeft gestuurd en de steward heeft een ingebouwde wacht procedure. Deze zal al een vaste tijd wachten tot er iets kan worden gelezen. Wanneer er een niet gesimuleerd bericht wordt verzonden kan dit tot 30 seconden duren voor dit echt aankomt. Dit hangt ook af van hoeveel keer de steward opnieuw moet proberen. Wanneer er vanuit de interface iets wordt gestuurd kan dit zelf langer zijn omdat eerst alle achtergrond messages moeten worden afgerond voordat het bericht dat is ingegeven kan worden verstuurd.
% subsubsection zigbee (end)
% subsection protocol (end)

\subsection{Simulatie}
\label{sub:simulation}
Er is ook een simulatie van een de zigbee devices aanwezig. Deze is te vinden \emph{xbee-simulation.rkt}. Alle procedures van het zigbee protocol (inclusief bytevector procedures uit slip) worden geleverd vanuit dit bestand. De R5RS versie van de steward importeert dit bestand en kan dus enkel gebruikt worden voor de simulatie.\\
Voorlopig worden er twee devices gesimuleerd, \'e\'en van elk ondersteund type. Nieuwe devices kunnen worden toegevoegd door ze aan de \textbf{SIM-DEVICES} lijst toe te voegen. Dit zijn de simpele device objecten. Er moet dan ook voor elke message die het device een vector aan \textbf{MESSAGES} worden toegevoegd. Deze vector staat en string versie van het bericht, een bytevector versie van het bericht, het antwoord frame (bytevector) en een lambda die wordt uitgevoerd voor het bericht in de antwoord queue wordt gestopt.\\
Wanneer er een frame wordt weggeschreven wordt het antwoord gezocht in \textbf{MESSAGES} eerst wordt dan de lambda uitgevoerd en dan wordt het in de \textbf{ANSWERS} lijst gestopt. Er wordt ook een succesvol status frame in deze lijst gestopt. Wanneer er dan een xbee-read optreed wordt het eerste element van de lijst teruggegeven.\\
Een simulatie van de steward kan worden gestart door start-simulation.rkt uit te voeren.
% subsection simulation (end)

% subsubsection  (end)

\subsection{Overzicht gebruikte talen en libraries}
\label{sub:langs}
\begin{itemize}
	\item[\textbf{Racket}] Code op de majordomo.
	\item[\textbf{Slip}] Code op de steward.
	\item[\textbf{R5RS}] Simulatie van de steward.
	\item[\textbf{HTML \& CSS}] Grafische interface.
	\item[\textbf{Javascript \& jQuery}] Interactieve elementen van de interface.
	\item[\textbf{Flot}] Weergeven van grafieken in de interface.
	\item[\textbf{sqlite3}] Database software.
\end{itemize}
% subsubsection langs (end)


% section developers (end)


\end{document}
